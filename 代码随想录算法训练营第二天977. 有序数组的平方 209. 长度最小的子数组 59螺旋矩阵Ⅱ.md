# 代码随想录算法训练营第二天|977. 有序数组的平方 209. 长度最小的子数组

## 977. 有序数组的平方

>学习文档：[卡哥讲解](https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)
>
>学习视频：[卡哥讲解](https://www.bilibili.com/video/BV1QB4y1D7ep/?vd_source=e7286a46021f9bac42b4a1d76b09fd72)
>
>题目简介：
>
>​	**给定一个<font color='red'>非递减</font> 的一个数组（包含负数）要求这个数组里面的每个元素平方之后，再进行递增排序。最后返回这个数组。**

### 自己手敲

没敲出来，看了一遍讲解以后

```python
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        #双指针法
        left , right ,new_nums = 0,len(nums)-1,[0]*len(nums)
        right_newnums = len(nums)-1
        while(left <= right ):
            if nums[left] **2 > nums[right]**2:
                new_nums[right_newnums] = nums[left]**2
                left += 1

            else:
                new_nums[right_newnums] = nums[right]**2
                right -=1
            right_newnums -= 1
        return new_nums
```

>思路：
>
>* 关键在于当**<font color='red'>数组两边要么是最大数最小数的时候</font> **，使用双指针法。
>
>* 需要再创建一个数组，以存放最大的数字。
>* 双指针 是针对 需要排序的数组，最左边一个指针，最右边一个指针。
>* 通过比较双指针指向的元素的平方大小，**<font color='red'>大的赋值往前走，小的不走停一停</font> **。

## 209. 长度最小的子数组

>学习文档 ：[卡哥讲解](https://leetcode.cn/problems/minimum-size-subarray-sum/)
>
>学习视频：[卡哥讲解](https://www.bilibili.com/video/BV1tZ4y1q7XE)
>
>题目简介：
>
>​	**给定一个正整数<font color='red'>Target</font> 以及一个全都是正整数的数组，找出一个连续的最小长度区间要求区间里面的数字之和大于等于该Target**

### 学习卡哥视频

* 本质上也是两个指针的操作
* 开始：两个指针都指向数组的第一个元素。一个叫**<font color='red'>Left</font> **，一个叫**<font color='red'>Right</font> **
* 开始寻找 **<font color='red'>>= Target</font> **,这里肯定需要一个**<font color='red'>SUM</font> **变量来累加
* **<font color='red'>Right往前走</font> **，走一个加一个，直到**<font color='red'>SUM>=Target</font> **
* **<font color='red'>Right停止</font> **，呼叫Left开始求最小长度。然后Left往前走，走一个**<font color='red'>SUM减一个</font> **，然后求**<font color='red'>min_len</font> **最小长度。在Left走的途中，**<font color='red'>SUM不满足>=Target</font> **了，Right又往前走，直到**<font color='red'>SUM>=Target</font> **或者走到头停下来，又开始让Left走。

自己按照理解手敲一遍:

```python
class Solution(object):
    def minSubArrayLen(self, target, nums):
        """
        :type target: int
        :type nums: List[int]
        :rtype: int
        """
        Left ,Right,Len_nums = 0,0,len(nums)-1
        sum = 0
        min_len = float('inf') ##错误1，为什么
        while(Right<= Len_nums):
            sum += nums[Right]
            while(sum >= target):
                min_len = min(min_len,Right-Left+1)
                sum -= nums[Left]
                Left += 1
            Right += 1
        return min_len if min_len != float('inf') else 0 ## 错误2
```

>错误1：**<font color='red'>为什么要使用 float('inf')？</font> **
>
>* **<font color='red'> float('inf')</font> ** 表示 正无穷大，在比较的时候确保可以更新最小的长度
>
>错误2 ： **<font color='red'>为什么要使用min_len if min_len != float('inf') else 0？</font> **
>
>* 因为数组中可能没有相匹配的元素，在返回的时候min_len 可能就没有更新。



## 59.螺旋矩阵 Ⅱ

>学习视频：[卡哥讲解](https://www.bilibili.com/video/BV1SL4y1N7mV/?spm_id_from=333.788&vd_source=e7286a46021f9bac42b4a1d76b09fd72)
>
>学习文档：[卡哥讲解](https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html#%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC)
>
>题目简介：
>
>​	**给一个<font color='red'>正整数n</font> ，要求生成一个<font color='red'>包含1到$n^2$</font> 所有元素，并且元素按照顺时针进行<font color='red'>螺旋排列</font> 到$n\times n$的正方形矩阵中。**

### 学习卡哥视频

* 遵循循环不变量（对每一条变的处理规则）的原则

自己按理解手敲一遍：

```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        nums = [[0] * n for _ in range(n)]
        startx, starty = 0, 0               
        loop, mid = n // 2, n // 2  # 错误1
        count = 1                           

        for offset in range(1, loop + 1) :      
            for i in range(starty, n - offset) :    
                nums[startx][i] = count
                count += 1
            for i in range(startx, n - offset) :    
                nums[i][n - offset] = count
                count += 1
            for i in range(n - offset, starty, -1) :  
                nums[n - offset][i] = count
                count += 1
            for i in range(n - offset, startx, -1) : 
                nums[i][starty] = count
                count += 1                
            startx += 1         
            starty += 1

        if n % 2 != 0 :			
            nums[mid][mid] = count #错误2
        return nums
```

>* 循环不变量为**<font color='red'>左闭右开</font> **
>
>* 错误1：loop = n//2
>
>  再求取循环的次数**<font color='red'>loop</font> **的时候，确保结果是一个整数.
>
>* 错误2：if n % 2 != 0 
>
>  对于奇数矩阵，最后的中心位置需要单独填充。
>
>



## 数组总结

1. 分别学习了**<font color='red'>二分查找</font> **、**<font color='red'>移除元素</font> **、**<font color='red'>有序数组的平方</font> **、**<font color='red'>长度最小的子数组</font> **、**<font color='red'>螺旋矩阵Ⅱ</font> **
2. 分别对应方法 **<font color='red'>二分查找法、双指针法、双指针法、滑动窗口（双指针）、循环不变量</font>**

3. 在数组中应当注意循环条件（左闭右开，左闭右闭），注意数组越界。
4. 对于新掌握的双指针法有不同的用法
   1. 用于删除元素，一个快一个慢，操作同一个数组，快的与慢的比较，**<font color='red'>满足条件慢的才往前走，快的一直走。</font> **
   2. 对于排序 ，**<font color='red'>再加一个新数组，一个最左一个最右，先比较再赋值再移动</font> **。
   3. 滑动窗口，**<font color='red'>两个指针开始都是在最左边</font> **，然后Right指针一直往右移动，直到满足条件停止。让Left移动，直到Left不满足某种条件，Right又开始移动，直到数组的边界。











